<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Elegant Dating Poster (Interactive)</title>
<style>
  :root {
    --rose-1: #fff4f6;
    --rose-2: #fbe8ec;
    --rose-3: #f0b4be;
    --rose-4: #b35269;
    --rose-5: #a86570;
    --text-1: #633d3d;
    --text-2: #c48c8c;
  }
  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
  }
  body {
    font-family: 'Playfair Display', serif;
    background: linear-gradient(180deg, var(--rose-1) 0%, var(--rose-2) 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 16px;
  }
  .poster {
    width: min(720px, 100%);
    background-color: #ffffff;
    border-radius: 16px;
    box-shadow: 0 10px 25px rgba(0,0,0,0.1);
    padding: clamp(16px, 3vw, 30px);
    text-align: center;
  }
  .frame-wrap {
    position: relative;
    width: 100%;
    aspect-ratio: 700 / 450; /* keeps the frame proportional on mobile */
    margin-bottom: 20px;
    background: #fff7f8;
    border: 2px dashed #d4a5a5;
    border-radius: 12px;
    overflow: hidden;
    touch-action: none; /* allow pinch/drag gestures */
  }
  .hint {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-2);
    font-size: 1.05rem;
    pointer-events: none;
    user-select: none;
  }
  #photo {
    position: absolute;
    top: 50%;
    left: 50%;
    transform-origin: 50% 50%;
    will-change: transform;
    user-select: none;
    -webkit-user-drag: none;
    touch-action: none;
    display: none; /* hidden until an image is loaded */
  }
  h1 {
    font-size: clamp(1.6rem, 2.5vw, 2.2rem);
    color: var(--rose-4);
    margin: 6px 0 10px 0;
    font-weight: 600;
  }
  p {
    font-size: clamp(1rem, 2.2vw, 1.1rem);
    color: var(--text-1);
    line-height: 1.55;
    margin: 0 0 14px 0;
  }
  .divider {
    width: 60%;
    height: 2px;
    background-color: var(--rose-3);
    margin: 14px auto 18px auto;
    border-radius: 2px;
  }
  .footer-text {
    font-style: italic;
    color: var(--rose-5);
  }
  /* small helper badge (not a button; purely informational) */
  .helper {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    font-size: 12px;
    color: #7a5f63;
    opacity: 0.85;
    margin-top: 6px;
  }
  input[type=file] { display: none; }
</style>
</head>
<body>
  <div class="poster">
    <div id="frame" class="frame-wrap" aria-label="Tap to choose a photo" role="button">
      <img id="photo" alt="Selected photo">
      <div id="hint" class="hint">Tap to choose a photo • Drag to move • Pinch/scroll to zoom</div>
    </div>
    <div class="helper">Tip: After adjusting, use your browser's “Share” or “Print → Save as PDF” to export.</div>

    <h1>Seeking a Genuine Gentleman</h1>
    <div class="divider"></div>
    <p>Confident, kind, and full of life – ready to share laughter and adventures. Looking for someone who appreciates authenticity, good conversation, and a hint of romance.</p>
    <p class="footer-text">“Because true connection never goes out of style.”</p>
  </div>

  <input id="picker" type="file" accept="image/*" capture="environment">

<script>
(function() {
  const frame = document.getElementById('frame');
  const img = document.getElementById('photo');
  const hint = document.getElementById('hint');
  const picker = document.getElementById('picker');

  // Transform state
  let scale = 1;
  let minScale = 1;
  let maxScale = 8;
  let tx = 0, ty = 0; // translation relative to center (px)
  let imgW = 0, imgH = 0;

  // Pointer tracking for drag and pinch
  const active = new Map(); // pointerId -> {x,y}
  let lastDistance = 0;

  // Open file picker when frame tapped/clicked
  frame.addEventListener('click', () => {
    // Only trigger click if we are not multi-touching
    if (active.size === 0) picker.click();
  });

  picker.addEventListener('change', (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      img.src = reader.result;
      img.style.display = 'block';
      hint.style.display = 'none';
    };
    reader.readAsDataURL(file);
  });

  img.addEventListener('load', () => {
    // Reset transform and fit to cover the frame
    const rect = frame.getBoundingClientRect();
    const fw = rect.width, fh = rect.height;

    // Natural size
    imgW = img.naturalWidth;
    imgH = img.naturalHeight;

    // Base scale to cover the frame
    const scaleX = fw / imgW;
    const scaleY = fh / imgH;
    minScale = Math.max(scaleX, scaleY);
    scale = minScale;
    maxScale = minScale * 8; // allow generous zoom
    tx = 0; ty = 0;
    applyTransform();
  });

  // Pointer events for drag + pinch
  frame.addEventListener('pointerdown', (e) => {
    frame.setPointerCapture(e.pointerId);
    active.set(e.pointerId, { x: e.clientX, y: e.clientY });
  });

  frame.addEventListener('pointermove', (e) => {
    if (!active.has(e.pointerId)) return;
    const prev = active.get(e.pointerId);
    const curr = { x: e.clientX, y: e.clientY };
    active.set(e.pointerId, curr);

    if (active.size === 1) {
      // Drag
      const dx = curr.x - prev.x;
      const dy = curr.y - prev.y;
      tx += dx;
      ty += dy;
      applyTransform();
    } else if (active.size >= 2) {
      // Pinch-zoom using first two pointers
      const [p1, p2] = Array.from(active.values()).slice(0, 2);
      const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
      if (lastDistance === 0) {
        lastDistance = dist;
        return;
      }
      const rect = frame.getBoundingClientRect();
      const mid = { x: (p1.x + p2.x) / 2 - rect.left, y: (p1.y + p2.y) / 2 - rect.top };
      zoomAt(dist / lastDistance, mid);
      lastDistance = dist;
    }
  });

  const endPointer = (e) => {
    if (active.has(e.pointerId)) active.delete(e.pointerId);
    if (active.size < 2) lastDistance = 0;
  };
  frame.addEventListener('pointerup', endPointer);
  frame.addEventListener('pointercancel', endPointer);
  frame.addEventListener('pointerleave', endPointer);

  // Wheel zoom (desktop)
  frame.addEventListener('wheel', (e) => {
    if (!img.src) return;
    e.preventDefault();
    const rect = frame.getBoundingClientRect();
    const point = { x: e.clientX - rect.left, y: e.clientY - rect.top };
    const factor = Math.pow(1.0018, -e.deltaY); // smooth zoom
    zoomAt(factor, point);
  }, { passive: false });

  function zoomAt(factor, point) {
    const prevScale = scale;
    scale = clamp(scale * factor, minScale * 0.6, maxScale);
    // Adjust translation so zoom centers around the interaction point
    const rect = frame.getBoundingClientRect();
    const cx = rect.width / 2;
    const cy = rect.height / 2;

    // Convert point to image-space translation adjustment
    // We shift by the vector from frame center to the point, scaled by zoom delta.
    const dx = (point.x - cx);
    const dy = (point.y - cy);
    const k = (scale / prevScale) - 1;
    tx -= dx * k;
    ty -= dy * k;
    applyTransform();
  }

  function applyTransform() {
    if (!img.src) return;
    img.style.transform = `translate(calc(-50% + ${tx}px), calc(-50% + ${ty}px)) scale(${scale})`;
    img.style.maxWidth = 'none';
    img.style.maxHeight = 'none';
  }

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
})();
</script>
</body>
</html>
